# 容器镜像安全

## 目录

- [容器镜像安全](#容器镜像安全)
  - [目录](#目录)
  - [1. 镜像安全概述](#1-镜像安全概述)
  - [2. 镜像安全威胁](#2-镜像安全威胁)
  - [3. 镜像安全扫描](#3-镜像安全扫描)
  - [4. 镜像签名与验证](#4-镜像签名与验证)
  - [5. 镜像构建安全](#5-镜像构建安全)
  - [6. 镜像分发安全](#6-镜像分发安全)
  - [7. 镜像存储安全](#7-镜像存储安全)
  - [8. 镜像安全策略](#8-镜像安全策略)
  - [9. 安全工具与平台](#9-安全工具与平台)
  - [10. 最佳实践](#10-最佳实践)

## 1. 镜像安全概述

### 1.1 镜像安全重要性

容器镜像是容器化应用的基础，镜像安全直接影响整个容器环境的安全性：

**镜像安全风险**：

- **恶意代码**：镜像可能包含恶意软件
- **漏洞利用**：镜像中的软件包可能存在已知漏洞
- **配置错误**：镜像配置可能导致安全风险
- **敏感信息**：镜像可能包含敏感数据
- **供应链攻击**：构建过程可能被污染

### 1.2 镜像安全生命周期

```text
┌─────────────────────────────────────────────────────────────┐
│                    镜像安全生命周期                         │
│                                                             │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐         │
│  │  构建   │  │  扫描   │  │  签名   │  │  分发   │         │
│  │ (Build) │  │(Scan)   │  │(Sign)   │  │(Distribute)│     │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘         │
│       │           │           │           │                │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐         │
│  │  验证   │  │  部署   │  │  监控   │  │  更新   │         │
│  │(Verify) │  │(Deploy) │  │(Monitor)│  │(Update) │         │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘         │
└─────────────────────────────────────────────────────────────┘
```

## 2. 镜像安全威胁

### 2.1 恶意镜像威胁

**恶意镜像类型**：

- **挖矿镜像**：包含加密货币挖矿软件
- **后门镜像**：包含远程访问后门
- **数据窃取镜像**：窃取敏感数据
- **僵尸网络镜像**：加入僵尸网络

**攻击手段**：

```bash
# 恶意镜像示例（仅用于演示）
FROM alpine:latest
RUN apk add --no-cache curl
# 恶意脚本
COPY malicious_script.sh /tmp/
RUN chmod +x /tmp/malicious_script.sh
CMD ["/tmp/malicious_script.sh"]
```

### 2.2 漏洞镜像威胁

**常见漏洞类型**：

- **操作系统漏洞**：基础镜像中的系统漏洞
- **应用漏洞**：应用程序中的安全漏洞
- **依赖漏洞**：第三方库中的漏洞
- **配置漏洞**：错误配置导致的安全问题

**漏洞影响评估**：

```yaml
# 漏洞严重性分级
severity_levels:
  critical: "9.0-10.0"    # 严重漏洞
  high: "7.0-8.9"         # 高危漏洞
  medium: "4.0-6.9"       # 中危漏洞
  low: "0.1-3.9"          # 低危漏洞
```

### 2.3 敏感信息泄露

**敏感信息类型**：

- **API密钥**：硬编码在镜像中的密钥
- **密码**：明文存储的密码
- **证书**：私钥和证书文件
- **配置信息**：包含敏感信息的配置文件

**检测方法**：

```bash
# 使用工具检测敏感信息
docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
  trufflesecurity/trufflehog:latest \
  docker --image=myapp:latest
```

## 3. 镜像安全扫描

### 3.1 扫描工具对比

| 工具 | 类型 | 特点 | 适用场景 |
|------|------|------|----------|
| **Trivy** | 开源 | 快速、准确、易用 | 开发环境、CI/CD |
| **Clair** | 开源 | 企业级、可扩展 | 生产环境 |
| **Anchore** | 商业 | 深度分析、策略引擎 | 企业级 |
| **Snyk** | 商业 | 依赖分析、修复建议 | 开发团队 |
| **Aqua** | 商业 | 全生命周期安全 | 企业级 |

### 3.2 Trivy扫描实践

**安装Trivy**：

```bash
# 使用包管理器安装
curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin

# 或使用Docker
docker pull aquasec/trivy:latest
```

**基础扫描**：

```bash
# 扫描本地镜像
trivy image myapp:latest

# 扫描远程镜像
trivy image registry.example.com/myapp:latest

# 扫描并生成报告
trivy image --format json --output report.json myapp:latest
```

**高级扫描选项**：

```bash
# 只扫描高危漏洞
trivy image --severity HIGH,CRITICAL myapp:latest

# 忽略特定漏洞
trivy image --ignorefile .trivyignore myapp:latest

# 扫描文件系统
trivy fs /path/to/directory
```

### 3.3 集成到CI/CD

**GitHub Actions集成**：

```yaml
name: Security Scan
on: [push, pull_request]

jobs:
  security-scan:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Build Docker image
      run: docker build -t myapp:${{ github.sha }} .
    
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: 'myapp:${{ github.sha }}'
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: 'trivy-results.sarif'
```

**Jenkins集成**：

```groovy
pipeline {
    agent any
    
    stages {
        stage('Build') {
            steps {
                sh 'docker build -t myapp:${BUILD_NUMBER} .'
            }
        }
        
        stage('Security Scan') {
            steps {
                sh '''
                    docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
                    aquasec/trivy:latest image myapp:${BUILD_NUMBER} \
                    --format json --output trivy-report.json
                '''
            }
        }
        
        stage('Security Gate') {
            steps {
                script {
                    def report = readJSON file: 'trivy-report.json'
                    def criticalVulns = report.Results.findAll { 
                        it.Vulnerabilities.any { vuln -> vuln.Severity == 'CRITICAL' }
                    }
                    if (criticalVulns.size() > 0) {
                        error "发现严重漏洞，构建失败"
                    }
                }
            }
        }
    }
}
```

## 4. 镜像签名与验证

### 4.1 数字签名原理

**签名流程**：

1. **生成密钥对**：创建公钥和私钥
2. **签名镜像**：使用私钥对镜像进行签名
3. **分发公钥**：将公钥分发给验证方
4. **验证签名**：使用公钥验证镜像完整性

### 4.2 Docker Content Trust

**启用DCT**：

```bash
# 设置环境变量
export DOCKER_CONTENT_TRUST=1

# 或使用命令行参数
docker --disable-content-trust=false push myapp:latest
```

**生成签名密钥**：

```bash
# 生成根密钥
docker trust key generate root

# 生成仓库密钥
docker trust key generate myapp

# 添加签名者
docker trust signer add --key myapp.pub myapp-signer myapp
```

**签名镜像**：

```bash
# 签名并推送
docker trust sign myapp:latest

# 查看签名信息
docker trust inspect myapp:latest
```

### 4.3 Notary集成

**Notary配置**：

```yaml
# notary-config.json
{
  "trust_dir": "~/.docker/trust",
  "remote_server": {
    "url": "https://notary.example.com",
    "root_ca": "/path/to/root-ca.crt"
  }
}
```

**使用Notary**：

```bash
# 初始化Notary仓库
notary init myapp

# 添加目标
notary add myapp latest myapp:latest

# 发布变更
notary publish myapp
```

## 5. 镜像构建安全

### 5.1 安全构建原则

**最小化原则**：

- 使用最小基础镜像
- 只安装必要的软件包
- 移除不必要的文件和工具

**示例安全Dockerfile**：

```dockerfile
# 使用官方最小镜像
FROM alpine:3.18

# 创建非root用户
RUN addgroup -g 1001 -S appgroup && \
    adduser -u 1001 -S appuser -G appgroup

# 设置工作目录
WORKDIR /app

# 复制应用文件
COPY --chown=appuser:appgroup app /app/

# 安装依赖（仅生产必需）
RUN apk add --no-cache --virtual .build-deps gcc musl-dev && \
    pip install --no-cache-dir -r requirements.txt && \
    apk del .build-deps

# 切换到非root用户
USER appuser

# 暴露端口
EXPOSE 8080

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

# 启动应用
CMD ["python", "app.py"]
```

### 5.2 多阶段构建安全

**安全多阶段构建**：

```dockerfile
# 构建阶段
FROM golang:1.21-alpine AS builder

# 设置构建环境
ENV CGO_ENABLED=0 GOOS=linux

# 复制源代码
WORKDIR /src
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN go build -ldflags="-w -s" -o app .

# 运行阶段
FROM scratch

# 复制CA证书
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/

# 复制应用
COPY --from=builder /src/app /app

# 设置用户
USER 1001:1001

# 启动应用
ENTRYPOINT ["/app"]
```

### 5.3 构建时安全扫描

**集成安全扫描**：

```dockerfile
# 使用安全扫描的构建
FROM alpine:3.18

# 安装安全工具
RUN apk add --no-cache \
    curl \
    jq \
    && curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin

# 复制应用
COPY app /app

# 构建时扫描
RUN trivy fs --exit-code 1 --severity HIGH,CRITICAL /app

# 其他构建步骤...
```

## 6. 镜像分发安全

### 6.1 私有镜像仓库

**Harbor配置**：

```yaml
# docker-compose.yml
version: '3.8'
services:
  harbor:
    image: goharbor/harbor-core:latest
    environment:
      - DATABASE_TYPE=postgresql
      - DATABASE_HOST=postgresql
      - DATABASE_PORT=5432
      - DATABASE_USERNAME=postgres
      - DATABASE_PASSWORD=password
      - REDIS_HOST=redis
      - REDIS_PORT=6379
    depends_on:
      - postgresql
      - redis
```

**访问控制**：

```bash
# 创建项目
curl -X POST "https://harbor.example.com/api/v2.0/projects" \
  -H "Content-Type: application/json" \
  -u admin:password \
  -d '{
    "project_name": "myapp",
    "metadata": {
      "public": "false"
    }
  }'

# 创建机器人账户
curl -X POST "https://harbor.example.com/api/v2.0/projects/myapp/robots" \
  -H "Content-Type: application/json" \
  -u admin:password \
  -d '{
    "name": "ci-robot",
    "description": "CI/CD机器人账户",
    "expires_at": 1735689600,
    "access": [
      {
        "resource": "/project/myapp/repository",
        "action": "push"
      }
    ]
  }'
```

### 6.2 镜像同步策略

**Harbor同步配置**：

```yaml
# 同步策略配置
sync_policies:
  - name: "production-sync"
    source_registry: "harbor-dev.example.com"
    target_registry: "harbor-prod.example.com"
    filters:
      - repository: "myapp/*"
        tag: "v*"
    schedule: "0 2 * * *"  # 每天凌晨2点同步
    enabled: true
```

### 6.3 镜像清理策略

**自动清理配置**：

```yaml
# 清理策略
cleanup_policies:
  - name: "keep-latest-10"
    description: "保留最新10个版本"
    rules:
      - repository: "myapp/*"
        keep_count: 10
        keep_days: 30
    schedule: "0 1 * * 0"  # 每周日凌晨1点执行
```

## 7. 镜像存储安全

### 7.1 存储加密

**镜像层加密**：

```bash
# 使用containerd加密
ctr images pull --encryption-key provider:key=mykey docker.io/library/alpine:latest

# 使用Docker加密
docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
  -e DOCKER_CONTENT_TRUST=1 \
  alpine:latest
```

### 7.2 访问控制

**文件系统权限**：

```bash
# 设置Docker目录权限
sudo chown -R root:docker /var/lib/docker
sudo chmod -R 755 /var/lib/docker

# 设置镜像存储权限
sudo chown -R docker:docker /var/lib/docker/image
sudo chmod -R 750 /var/lib/docker/image
```

### 7.3 存储监控

**存储使用监控**：

```bash
# 监控Docker存储使用
docker system df

# 清理未使用的镜像
docker image prune -a

# 清理未使用的容器
docker container prune

# 清理未使用的网络
docker network prune

# 清理未使用的卷
docker volume prune
```

## 8. 镜像安全策略

### 8.1 安全策略定义

**策略示例**：

```yaml
# 镜像安全策略
image_security_policy:
  # 基础镜像要求
  base_image:
    allowed_registries:
      - "registry.example.com"
      - "docker.io"
    blocked_registries:
      - "untrusted-registry.com"
    required_labels:
      - "security.scan"
      - "build.date"
  
  # 漏洞要求
  vulnerabilities:
    max_critical: 0
    max_high: 2
    max_medium: 10
    auto_fix: true
  
  # 签名要求
  signing:
    required: true
    trusted_signers:
      - "myapp-signer"
  
  # 大小限制
  size:
    max_size: "500MB"
    max_layers: 20
```

### 8.2 策略执行

**Gatekeeper策略**：

```yaml
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequiredlabels
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredLabels
      validation:
        properties:
          labels:
            type: array
            items:
              type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredlabels
        
        violation[{"msg": msg}] {
          required := input.parameters.labels
          provided := input.review.object.metadata.labels
          missing := required[_]
          not provided[missing]
          msg := sprintf("Missing required label: %v", [missing])
        }
---
apiVersion: config.gatekeeper.sh/v1alpha1
kind: K8sRequiredLabels
metadata:
  name: must-have-security-labels
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment"]
  parameters:
    labels: ["security.scan", "build.date"]
```

### 8.3 合规检查

**合规检查脚本**：

```bash
#!/bin/bash
# 镜像合规检查脚本

check_image_compliance() {
    local image=$1
    
    echo "检查镜像: $image"
    
    # 检查签名
    if ! docker trust inspect "$image" >/dev/null 2>&1; then
        echo "❌ 镜像未签名"
        return 1
    fi
    
    # 检查漏洞
    local vuln_count=$(trivy image --format json "$image" | jq '.Results[].Vulnerabilities | length')
    if [ "$vuln_count" -gt 5 ]; then
        echo "❌ 漏洞数量过多: $vuln_count"
        return 1
    fi
    
    # 检查大小
    local size=$(docker images --format "{{.Size}}" "$image" | sed 's/[^0-9.]//g')
    if (( $(echo "$size > 500" | bc -l) )); then
        echo "❌ 镜像过大: ${size}MB"
        return 1
    fi
    
    echo "✅ 镜像合规检查通过"
    return 0
}

# 使用示例
check_image_compliance "myapp:latest"
```

## 9. 安全工具与平台

### 9.1 商业安全平台

**Aqua Security**：

- 全生命周期容器安全
- 运行时保护
- 合规管理
- 威胁检测

**Twistlock (Prisma Cloud)**：

- 容器安全扫描
- 运行时保护
- 网络微隔离
- 合规检查

**Sysdig Secure**：

- 容器安全监控
- 运行时保护
- 合规管理
- 威胁检测

### 9.2 开源安全工具

**Falco**：

```yaml
# falco规则示例
- rule: Unauthorized process in container
  desc: Detect unauthorized processes in containers
  condition: >
    spawned_process and
    container and
    not proc.name in (nginx, apache, python, node, java)
  output: >
    Unauthorized process in container
    (user=%user.name command=%proc.cmdline container=%container.name)
  priority: WARNING
```

**OPA Gatekeeper**：

```yaml
# 镜像安全策略
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8simagesecurity
spec:
  crd:
    spec:
      names:
        kind: K8sImageSecurity
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8simagesecurity
        
        violation[{"msg": msg}] {
          image := input.review.object.spec.containers[_].image
          not startswith(image, "registry.example.com/")
          msg := sprintf("Image must be from trusted registry: %v", [image])
        }
```

### 9.3 集成方案

**CI/CD集成**：

```yaml
# GitLab CI集成
stages:
  - build
  - security-scan
  - deploy

build:
  stage: build
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA

security-scan:
  stage: security-scan
  script:
    - trivy image --exit-code 1 --severity HIGH,CRITICAL $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
        aquasec/trivy:latest image --format json --output report.json $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  artifacts:
    reports:
      junit: report.json
  only:
    - main
    - develop
```

## 10. 最佳实践

### 10.1 镜像安全最佳实践

**构建阶段**：

1. 使用官方基础镜像
2. 定期更新基础镜像
3. 最小化镜像大小
4. 使用非root用户
5. 移除不必要的工具

**扫描阶段**：

1. 集成到CI/CD流程
2. 设置安全门禁
3. 定期扫描漏洞
4. 及时修复漏洞
5. 记录扫描结果

**分发阶段**：

1. 使用私有仓库
2. 启用内容信任
3. 实施访问控制
4. 监控分发活动
5. 定期清理镜像

### 10.2 安全策略模板

**企业级安全策略**：

```yaml
# 企业镜像安全策略
enterprise_image_security_policy:
  # 基础要求
  requirements:
    - 所有镜像必须签名
    - 所有镜像必须扫描
    - 禁止使用root用户
    - 禁止包含敏感信息
  
  # 漏洞管理
  vulnerability_management:
    critical: 0      # 不允许严重漏洞
    high: 1          # 最多1个高危漏洞
    medium: 5        # 最多5个中危漏洞
    auto_fix: true   # 自动修复
  
  # 镜像管理
  image_management:
    max_size: "1GB"
    max_layers: 30
    retention_days: 90
    auto_cleanup: true
  
  # 访问控制
  access_control:
    require_authentication: true
    require_authorization: true
    audit_logging: true
```

### 10.3 监控与告警

**监控指标**：

```yaml
# 镜像安全监控指标
monitoring_metrics:
  - name: "image_vulnerability_count"
    description: "镜像漏洞数量"
    type: "gauge"
    labels: ["image", "severity"]
  
  - name: "image_scan_duration"
    description: "镜像扫描耗时"
    type: "histogram"
    labels: ["image", "scanner"]
  
  - name: "image_pull_failures"
    description: "镜像拉取失败次数"
    type: "counter"
    labels: ["image", "error_type"]
```

**告警规则**：

```yaml
# Prometheus告警规则
groups:
  - name: image_security
    rules:
      - alert: HighVulnerabilityCount
        expr: image_vulnerability_count{severity="high"} > 3
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "镜像高危漏洞数量过多"
          description: "镜像 {{ $labels.image }} 有 {{ $value }} 个高危漏洞"
      
      - alert: ImageScanFailure
        expr: increase(image_scan_failures_total[5m]) > 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "镜像扫描失败"
          description: "镜像 {{ $labels.image }} 扫描失败"
```

### 10.4 应急响应

**安全事件响应流程**：

1. **检测**：发现安全事件
2. **分析**：分析事件影响
3. **响应**：采取响应措施
4. **恢复**：恢复正常服务
5. **总结**：总结经验教训

**响应脚本**：

```bash
#!/bin/bash
# 镜像安全事件响应脚本

respond_to_security_incident() {
    local image=$1
    local severity=$2
    
    echo "响应安全事件: $image ($severity)"
    
    case $severity in
        "critical")
            # 立即停止使用镜像
            docker stop $(docker ps -q --filter ancestor="$image")
            # 从仓库中移除镜像
            docker rmi "$image"
            # 发送紧急通知
            send_alert "CRITICAL" "镜像 $image 发现严重安全漏洞"
            ;;
        "high")
            # 标记镜像为不安全
            docker tag "$image" "$image:unsafe"
            # 计划维护窗口
            schedule_maintenance_window
            ;;
        "medium")
            # 记录事件
            log_security_event "$image" "$severity"
            # 计划修复
            schedule_fix "$image"
            ;;
    esac
}

send_alert() {
    local level=$1
    local message=$2
    
    # 发送邮件
    echo "$message" | mail -s "安全告警 [$level]" security@company.com
    
    # 发送Slack消息
    curl -X POST -H 'Content-type: application/json' \
        --data "{\"text\":\"$message\"}" \
        "$SLACK_WEBHOOK_URL"
}
```

## 总结

容器镜像安全是容器安全的重要组成部分，需要从构建、扫描、签名、分发、存储等多个环节进行防护。通过建立完善的安全策略、使用专业的安全工具、实施严格的访问控制，可以有效保障容器镜像的安全性。

关键要点：

- **多层防护**：从多个层面进行安全防护
- **自动化扫描**：集成到CI/CD流程中
- **数字签名**：确保镜像完整性和来源可信
- **访问控制**：严格控制镜像访问权限
- **持续监控**：实时监控镜像安全状态
- **应急响应**：建立完善的安全事件响应机制
